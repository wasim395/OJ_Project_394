const { callLLM } = require("./llmClient");
const Problem = require("../../models/Problems.js");

const BATCH_SIZE = 3;
const MAX_RETRIES = 3;

async function generateHiddenTestCases(problemId, n = 0) {
    if (n <= 0) return null;

    const problem = await Problem.findById(problemId);
    if (!problem) throw new Error("Problem not found");

    const newHiddenCases = [];

    for (let batchStart = 0; batchStart < n;) {
        const batchSize = Math.min(BATCH_SIZE, n - batchStart);
        let attempts = 0;
        let batchCases = null;

        while (attempts < MAX_RETRIES && !batchCases) {
            attempts++;
            const prompt = `
You are a strict JSON emitter. 
1. Output ONLY a JSON array, nothing else. 
2. Do NOT wrap the JSON in markdown fences, back-ticks, or prose.
3. Each element MUST be an object with exactly two string keys:
   - "input"   : string
   - "output"  : string
4. Do NOT include comments, trailing commas, or additional keys.

TASK:
Generate ${batchSize} robust hidden test cases for the coding problem below.

PROBLEM SPECS (read-only):
${JSON.stringify(
                {
                    title: problem.title,
                    problemStatement: problem.problemStatement,
                    expectedInput: problem.expectedInput,
                    expectedOutput: problem.expectedOutput,
                    constraints: problem.constraints,
                },
                null,
                2
            )}

REMINDERS:
- Escape any newline in "input" with \\n.
- Keep the JSON compact (no pretty-printing needed).
- Validate the JSON before replying.

NOW RETURN THE JSON ARRAY ONLY:
`;

            const raw = await callLLM(prompt);
            console.log(`LLM attempt ${attempts} raw output:`, raw);

            const match = raw.match(/\[[\s\S]*\]/);
            if (match) {
                try {
                    const parsed = JSON.parse(match[0]);
                    if (Array.isArray(parsed) && parsed.length > 0) {
                        batchCases = parsed;
                    }
                } catch (e) {
                    // retry
                }
            }
        }

        if (!batchCases) {
            throw new Error(
                `LLM failed to generate valid JSON after ${MAX_RETRIES} attempts`
            );
        }

        // Accept string or number outputs
        const validCases = batchCases
            .filter(
                tc =>
                    tc &&
                    typeof tc.input === "string" &&
                    (typeof tc.output === "string" || typeof tc.output === "number")
            )
            .map(tc => ({
                input: tc.input,
                output: String(tc.output)
            }));

        if (validCases.length === 0) {
            throw new Error("No valid test cases generated by LLM");
        }

        newHiddenCases.push(...validCases.slice(0, batchSize));
        batchStart += batchSize;
    }

    problem.hiddenTestCases = [...(problem.hiddenTestCases || []), ...newHiddenCases];
    problem.status = "draft";
    await problem.save();

    return problem;
}

module.exports = { generateHiddenTestCases };
